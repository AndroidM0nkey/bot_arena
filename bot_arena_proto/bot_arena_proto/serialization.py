from bot_arena_proto.error import ProtocolError

from abc import abstractmethod
from typing import Protocol, Type, TypeVar, Union, Optional, Any

# No type hints available for this library, unfortunately.
import cbor2  # type: ignore


__all__ = [
    'DeserializationAdtTagError',
    'DeserializationError',
    'DeserializationLogicError',
    'DeserializationTypeError',
    'Primitive',
    'PrimitiveSerializable',
    'Serializable',
    'SerializableSelfType',
    'ensure_type',
]


# Self type. See https://github.com/python/mypy/issues/1212
SerializableSelfType = TypeVar('SerializableSelfType', covariant=True, bound='Serializable')

# Unfortunately, mypy does not yet seem to support proper recursive type definition
Primitive = Union[dict, list, str, int, float, bool, None]


class Serializable(Protocol):
    """A type that can be serialized into and deserialized from a byte string."""

    @abstractmethod
    def to_bytes(self) -> bytes:
        """Serialize self into a byte string."""
        ...

    @classmethod
    @abstractmethod
    def from_bytes(Class: Type[SerializableSelfType], b: bytes) -> SerializableSelfType:
        """Deserialize from a byte string."""
        ...


class PrimitiveSerializable(Serializable, Protocol):
    """A type that can be serialized into and deserialized from a primitive.

    It is usually very convenient to serialize a class not directly to a byte
    string, but to some kind of an intermediate representation (comprised of
    lists, dicts and Python primitive types), which can later be serialized
    to a byte string as a whole. This is so because of two main reasons.

    1. It is format agnostic. The (de)serialization code does not need to
       know to/from which binary or text format (JSON, CBOR, XML, etc.) it is
       serialized/deserialized.
    2. Efficient recursion is trivial. Assume that you have a class that
       stores a list of some objects. If you can only serialize them directly to
       byte strings, it is not obvious how to serialize the container class. Of
       course you can serialize it as a list of byte strings, but this is likely
       to result in unnecessary computational and space overhead. If, however,
       you can serialize each object into the intermediate representation, you
       can simply construct a list of the resulting instances of the intermediate
       representation, and this is going to be the result of the serialization.
       Virtually no overhead is generated by this, and the resulting encoding of
       this intermediate representation into a byte string is likely to be shorter
       than in the former case. The deserialization works in exactly the same way.

    Since the intermediate representation is comprised of a limited number
    of Python types, we can refer to these types as `Primitive`s. Hence, we
    will use the term "primitive" to refer to an instance of the intermediate
    representation in question.

    This abstract class also provides a method to convert between a primitive
    and a byte string. Thus, it suffices for a class to implement methods
    of this abstract class to become an instance of `Serializable`.
    """

    @abstractmethod
    def to_primitive(self) -> Primitive:
        """Serialize self into a primitive."""
        ...

    @classmethod
    @abstractmethod
    def from_primitive(Class, p: Primitive) -> Any:
        """Deserialize from a primitive."""
        ...

    def to_bytes(self) -> bytes:
        # First, serialize self into a primitive.
        primitive = self.to_primitive()

        # Second, encode this primitive in CBOR (see https://cbor.io).
        return cbor2.dumps(primitive)

    @classmethod
    def from_bytes(Class: Type[SerializableSelfType], b: bytes) -> SerializableSelfType:
        # First, decode the byte string into the intermediate representation.
        primitive = cbor2.loads(b)

        # Second, deserialize the instance from it.
        # Mypy complaints are silenced at this point because I'm around 40
        # minutes into coding this and I'm already tired of the
        # helplessness of the static typing implementation in Python.
        #
        # Really: it has union types, but mypy (read: the reference implementation
        # of a static type checker) does not support recursive types, making
        # it impossible to really take advantage of union types except in trivial
        # cases. Say, you just can't make a `Primitive` type being something
        # like `Union[int, str, float, bool, Dict[str, Primitive], List[Primitive]]`,
        # which is how it is done in some other languages; which is how most
        # JSON/CBOR/whatever libraries would see the possible decoded value; which
        # is just reasonable and sane, after all. But no, mypy just cannot do this.
        # There is an issue tracking this unfortunate situation
        # (https://github.com/python/mypy/issues/731), but it's been 5 years since it
        # was opened, and there's been not much progress since then.
        #
        # Now, Self types. A concept totally missing from most OO languages despite
        # being able to make programmers' lives easier. How do you define an interface
        # for a class having a static method that returns an instance of this specific
        # class? In most object-oriented programming languages you don't. You just
        # cannot do this. But this is Python, can we do such a thing here? Well...
        # the true answer is probably still no, but there are some workarounds that
        # are ugly and work in a subset of all cases. Again, there is an mypy issue
        # tracking this (https://github.com/python/mypy/issues/1212), but this is
        # kind of "resolved" just by allowing those workarounds. I still cannot write
        # code as concise as this example:
        #
        # ```
        # from typing import Self, Protocol
        #
        # class Deserializable(Protocol):
        #     @staticmethod
        #     def deserialize(b: bytes) -> Self: ...
        # ```
        #
        # Of course we can use `Deserializable` itself as the return type, but this
        # destroys most of the benefits of static typing in this case: if a class
        # `Foo` implements this `Deserializable`, and we call `Foo.deserialize(b'12345')`,
        # then the static type system won't be able to tell that we will get an
        # instance of `Foo` as the result.
        #
        # Again, luckily, in Python there are workarounds allowing this behavior,
        # but they (1) are ugly (and involve a separate type variable and
        # `@classmethod`) and (2) don't seem to play very well with subtyping.
        #
        # This can be possibly fixed or worked around even more, but I'm just tired
        # of fighting with the type checker and trying to explain to it fundamental
        # things that haven't been initially thought of. So, at least for now,
        # let us leave this mypy warning ignored.
        return Class.from_primitive(primitive)  # type: ignore


class DeserializationError(ProtocolError):
    """Base class for errors occuring during deserialization."""

    def __init__(self, comment: Optional[str] = None) -> None:
        super().__init__()
        self.comment = comment

    def fmt_comment(self) -> str:
        if self.comment is None:
            return ''
        else:
            return ' of value ' + self.comment

    def __str__(self) -> str:
        return repr(self)

    def __repr__(self) -> str:
        return f'During deserialization{self.fmt_comment()}, {self.describe_error()}'

    @abstractmethod
    def describe_error(self) -> str:
        ...


class DeserializationTypeError(DeserializationError):
    """Deserialization error when a value was deserialized
    into a certain type, but another one was expected.
    """

    def __init__(self, Expected: type, Actual: type, comment: Optional[str] = None) -> None:
        super().__init__(comment)
        self.Expected = Expected
        self.Actual = Actual

    def describe_error(self) -> str:
        return f'the type `{self.Actual}` arised, while the code expected `{self.Expected}`'


class DeserializationAdtVariantUnexpectedError(DeserializationError):
    """Deserialization error when a variant of an ADT was not expected in this place."""

    def __init__(self, Adt: type, variant: Any, comment: Optional[str] = None) -> None:
        super().__init__(comment)
        self.Adt = Adt
        self.variant = variant

    def describe_error(self) -> str:
        return f'the unexpected variant {self.variant!r} of {self.Adt!r} arised'


class DeserializationAdtTagError(DeserializationError):
    """Deserialization error when a tag not present in the
    deserialized algebraic data type is encountered.
    """

    def __init__(self, Adt: type, tag: str, comment: Optional[str] = None) -> None:
        super().__init__(comment)
        self.Adt = Adt
        self.tag = tag

    def describe_error(self) -> str:
        return f'the tag {repr(self.tag)} arised, which is not valid for the algebraic data type {self.Adt}'


class DeserializationLogicError(DeserializationError):
    """Miscellaneous deserialization error. Custom description is provided."""

    def __init__(self, message: str, comment: Optional[str] = None) -> None:
        super().__init__(comment)
        self.message = message

    def describe_error(self) -> str:
        return self.message


class DeserializationKeyError(DeserializationError):
    """Failed to look up a key in a deserialized dict."""

    def __init__(self, key: str, comment: Optional[str] = None) -> None:
        super().__init__(comment)
        self.key = key

    def describe_error(self) -> str:
        return f'missing key: {self.key!r}'


class DeserializationIndexError(DeserializationError):
    """The length of a deserialized list is too small."""

    def __init__(self, comment: Optional[str] = None) -> None:
        super().__init__(comment)

    def describe_error(self) -> str:
        return f'list too short'


class DeserializationValueError(DeserializationError):
    """A deserialized value is not valid or allowed."""

    def __init__(self, value: Any, comment: Optional[str] = None) -> None:
        super().__init__(comment)
        self.value = value

    def describe_error(self) -> str:
        return f'invalid or forbidden value: {self.value!r}'


_T = TypeVar('_T')

def ensure_type(value: Any, Tp: Type[_T], comment: Optional[str] = None) -> _T:
    """Helper function that ensures that a value has a certain type.

    If `isinstance(value, Tp)` returns False, then DeserializationTypeError
    is raised. Otherwise, the value is returned unmodified, but, from the
    perspective of a static type checker, it is guaranteed to have the type
    `Tp`.  Hence, a typical usage pattern, which would also please a static
    type checker, would be:

        raw_deserialized_value = ...
        deseriazed_value = ensure_type(
            raw_deserialized_value,
            Foo,
            comment='Some optional comment',
        )
        deserialized_value.foo()
    """

    if isinstance(value, Tp):
        return value
    raise DeserializationTypeError(Expected=Tp, Actual=type(value), comment=comment)


def unwrap_variant(message: Any, variant: str) -> Any:
    try:
        return getattr(message, variant)()
    except AttributeError as e:
        if 'was constructed' in str(e):
            raise DeserializationAdtVariantUnexpectedError(type(message), variant)
        raise


def wrap_deserialization_errors(func):
    def inner(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ValueError as e:
            raise DeserializationValueError(str(e))
        except IndexError as e:
            raise DeserializationIndexError()
        except KeyError as e:
            raise DeserializationKeyError(str(e))

    inner.__name__ = func.__name__
    return inner
