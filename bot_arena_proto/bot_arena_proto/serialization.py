from abc import abstractmethod
from typing import Protocol, Type, TypeVar, Union

# No type hints available for this library, unfortunately.
import cbor2  # type: ignore


# Self type. See https://github.com/python/mypy/issues/1212
SerializableSelfType = TypeVar('SerializableSelfType', covariant=True, bound='Serializable')

# Unfortunately, mypy does not yet seem to support proper recursive type definition
Primitive = Union[dict, list, str, int, float, bool, None]


class Serializable:
    """A type that can be serialized into and deserialized from a byte string."""

    @abstractmethod
    def to_bytes(self) -> bytes:
        """Serialize self into a byte string."""
        ...

    @classmethod
    @abstractmethod
    def from_bytes(Class: Type[SerializableSelfType], b: bytes) -> SerializableSelfType:
        """Deserialize from a byte string."""
        ...


class PrimitiveSerializable(Serializable):
    """A type that can be serialized into and deserialized from a primitive.

    It is usually very convenient to serialize a class not directly to a byte
    string, but to some kind of an intermediate representation (comprised of
    lists, dicts and Python primitive types), which can later be serialized
    to a byte string as a whole. This is so because of two main reasons.

    1. It is format agnostic. The (de)serialization code does not need to
       know to/from which binary or text format (JSON, CBOR, XML, etc.) it is
       serialized/deserialized.
    2. Efficient recursion is trivial. Assume that you have a class that
       stores a list of some objects. If you can only serialize them directly to
       byte strings, it is not obvious how to serialize the container class. Of
       course you can serialize it as a list of byte strings, but this is likely
       to result in unnecessary computational and space overhead. If, however,
       you can serialize each object into the intermediate representation, you
       can simply construct a list of the resulting instances of the intermediate
       representation, and this is going to be the result of the serialization.
       Virtually no overhead is generated by this, and the resulting encoding of
       this intermediate representation into a byte string is likely to be shorter
       than in the former case. The deserialization works in exactly the same way.

    Since the intermediate representation is comprised of a limited number
    of Python types, we can refer to these types as `Primitive`s. Hence, we
    will use the term "primitive" to refer to an instance of the intermediate
    representation in question.

    This abstract class also provides a method to convert between a primitive
    and a byte string. Thus, it suffices for a class to implement methods
    of this abstract class to become an instance of `Serializable`.
    """

    @abstractmethod
    def to_primitive(self) -> Primitive:
        """Serialize self into a primitive."""
        ...

    @classmethod
    @abstractmethod
    def from_primitive(Class: Type[SerializableSelfType], p: Primitive) -> SerializableSelfType:
        """Deserialize from a primitive."""
        ...

    def to_bytes(self) -> bytes:
        # First, serialize self into a primitive.
        primitive = self.to_primitive()

        # Second, encode this primitive in CBOR (see https://cbor.io).
        return cbor2.dumps(primitive)

    @classmethod
    def from_bytes(Class: Type[SerializableSelfType], b: bytes) -> SerializableSelfType:
        # First, decode the byte string into the intermediate representation.
        primitive = cbor2.loads(b)

        # Second, deserialize the instance from it.
        # Mypy complaints are silenced at this point because I'm around 40
        # minutes into coding this and I'm already tired of the
        # helplessness of the static typing implementation in Python.
        #
        # Really: it has union types, but mypy (read: the reference implementation
        # of a static type checker) does not support recursive types, making
        # it impossible to really take advantage of union types except in trivial
        # cases. Say, you just can't make a `Primitive` type being something
        # like `Union[int, str, float, bool, Dict[str, Primitive], List[Primitive]]`,
        # which is how it is done in some other languages; which is how most
        # JSON/CBOR/whatever libraries would see the possible decoded value; which
        # is just reasonable and sane, after all. But no, mypy just cannot do this.
        # There is an issue tracking this unfortunate situation
        # (https://github.com/python/mypy/issues/731), but it's been 5 years since it
        # was opened, and there's been not much progress since then.
        #
        # Now, Self types. A concept totally missing from most OO languages despite
        # being able to make programmers' lives easier. How do you define an interface
        # for a class having a static method that returns an instance of this specific
        # class? In most object-oriented programming languages you don't. You just
        # cannot do this. But this is Python, can we do such a thing here? Well...
        # the true answer is probably still no, but there are some workarounds that
        # are ugly and work in a subset of all cases. Again, there is an mypy issue
        # tracking this (https://github.com/python/mypy/issues/1212), but this is
        # kind of "resolved" just by allowing those workarounds. I still cannot write
        # code as concise as this example:
        #
        # ```
        # from typing import Self, Protocol
        #
        # class Deserializable(Protocol):
        #     @staticmethod
        #     def deserialize(b: bytes) -> Self: ...
        # ```
        #
        # Of course we can use `Deserializable` itself as the return type, but this
        # destroys most of the benefits of static typing in this case: if a class
        # `Foo` implements this `Deserializable`, and we call `Foo.deserialize(b'12345')`,
        # then the static type system won't be able to tell that we will get an
        # instance of `Foo` as the result.
        #
        # Again, luckily, in Python there are workarounds allowing this behavior,
        # but they (1) are ugly (and involve a separate type variable and
        # `@classmethod`) and (2) don't seem to play very well with subtyping.
        #
        # This can be possibly fixed or worked around even more, but I'm just tired
        # of fighting with the type checker and trying to explain to it fundamental
        # things that haven't been initially thought of. So, at least for now,
        # let us leave this mypy warning ignored.
        return Class.from_primitive(primitive)  # type: ignore
