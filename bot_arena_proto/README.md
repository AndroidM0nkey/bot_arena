# BotArena protocol library

Provides a high-level and a low-level interface to the communication between a client and a server.
The low-level interface provides the facilities to send and receive messages. The high-level interface
builds upon this message exchange and provides an easier to use and perhaps more intuitive
set of functionality.

## API reference
**TL;DR**: docstrings are available, to build and view HTML documentation out of them
run `cd doc && ./build.sh && ./run.sh` (Python package `pdoc3` must be installed).
Also available [online](https://kodopp.mooo.com/bot_arena/api-docs).

This library attempts to provide the docstrings for every non-internal class, function and method.
These can be either viewed in the source code, or accessed by the Python's `help(...)`
function. For example, if you want to see the documentation for `message.Message`
you can either look into the `bot_arena_proto/message.py` file and find the `Message`
class there, or start the Python interpreter and type the following:

```python
from bot_arena_proto.message import Message
help(Message)
```

As an alternative, HTML documentation can be generated by running `cd doc && ./build.sh`.
`build.sh` requires Python package `pdoc3` to be installed.
This documentation can be viewed with a web browser by opening HTML files manually
or by running `./host.sh`, which will start a local HTTP server with the documentation.
GitHub releases also contain pre-build documentation, so it may not necessary to build
it at all.

## High-level API: Session
**Note**: unless explicitly stated otherwise, everything mentioned
resides in the `session` module.

The high-level interface provided by this library is session-oriented.
Whether this library is used on the client or the server side, the user
is expected to create a corresponding `Session` object (namely `ClientSession`
or `ServerSession`) to begin the communication.

### Client session
To construct a `ClientSession` object, you need to provide a stream from which
bytes can be read and to which they can be written and the information about
the client in the form of a `ClientInfo` object. The stream can be a TCP stream,
a named or unnamed pipe or even something that just emulates real `read` and `write`
operations. The necessary methods of a stream, `.read()` and `.write()`, are described
in the `Stream` protocol. The information about the client currently contains
only the name of the player (and the snake it controls).

After a `ClientSession` object has been created, it is necessary to call
`.initialize()` on it to complete the handshake between the client
and the server. Under the hood, it sends a `CLIENT_HELLO` and receives
a `SERVER_HELLO` message.

After that, the client has to call `.ready()` to signal to the server that
it is ready to enter a game. This is not done automatically by `.initialize()`
because potentially a client may want to perform some actions (e.g. list the players
or change the name) before the game starts, but after the handshake has been completed.
At the moment, there are no such supported actions, but they may be introduced later.

`.ready()` is non-blocking: it does not wait until the game is actually started.
To wait until this happens, the client should call the `.wait_until_game_started()`
method. It returns the `GameInfo` object sent to you by the server, where
there is information about the size of the game field.

When the game starts, the server is supposed to notify the client of any events and changes.
The method `.wait_for_notification()` blocks until a message from the server is received
and returns a `ClientNotification` object. It is an algebraic data type that represents
serveral possible types of notifications:

- `REQUEST`: The server asks you to take your turn.
- `FIELD_STATE`: A new state of the game field is available.
- `EVENT`: Some event has happened. See `event.Event` for details.
- `ERROR`: Indicates an error in your previous request or response.

When the server asks you to take turn, you are supposed to reply with an action (see `data.Action`).
This is what the `.respond()` method is for. You have to construct a `data.Action` object
and then call `.respond()` with this object being a parameter.

#### Example

This is an example on how to use the `ClientSession` class to communicate with a server
from the client side.

```python
from bot_arena_proto.data import *
from bot_arena_proto.event import Event
from bot_arena_proto.session import ClientSession, ClientInfo

# A library that can run async functions.
# Standard `asyncio` can also be used, although with some tweaks.
# (needs `curio` package installed)
import curio

# Session, shared between functions.
# A properly designed program should probably avoid
# using global variables, but this is just a tiny example.
sess = None

async def main():
    global sess

    # Connect to the server, assuming it is listening on 127.0.0.1:1234.
    socket = await curio.open_connection(host='127.0.0.1', port=1234)

    # We need an object with read/write methods. In curio, sockets have
    # recv/send methods, and streams have read/write methods. Hence, we need
    # to convert the socket to a stream. Consult the documentation
    # (https://curio.readthedocs.io/en/latest/reference.html#networking)
    # for details.
    stream = socket.as_stream()

    # [[[ Interesting things start here ]]]

    # Create a ClientSession
    client_info = ClientInfo(name='Player 1')
    sess = ClientSession(stream=stream, client_info=client_info)

    # Perform the handshake
    await sess.initialize()

    # Enter some game room
    await sess.enter_any_room()

    # If we have created a game, make it open for everyone
    props = await sess.get_room_properties()
    if client_info.name in props['admins']:
        await sess.set_room_properties({'open': RoomOpenness.OPEN()})

    # Start the game
    await sess.ready()
    game_info = await sess.wait_until_game_started()

    # Important data
    field_width = game_info.field_width
    field_height = game_info.field_height

    # Handle server-sent notifications
    while True:
        notification = await sess.wait_for_notification()

        # Handle the notification. See the documentation for the
        # `algebraic-data-type` package.
        #
        # Note: the functions `take_turn`, `handle_new_field_state`, `handle_event`
        # and `handle_error` are async, and the result of the `.match()` method
        # is awaited. This is correct and probably the only way to combine pattern
        # matching with asynchronous IO because the following actually happens:
        #
        # (1) `.match()` method calls (but does not await) one of these four functions.
        # (2) This function returns a `coroutine` object, which can be awaited.
        # (3) This object is the value returned from `.match()`.
        # (4) This object is then awaited.
        await notification.match(
            request = take_turn,
            field_state = handle_new_field_state,
            event = handle_event,
            error = handle_error,
        )

async def handle_new_field_state(state):
    # Do something when a new field state arrives.
    print(f'New field state: {state}')

async def handle_event(event):
    # Do something when an event happens.
    print(f'Event happened: {event}')

async def handle_error(description):
    # Do something when an error happens.
    print(f'Error: {description}')

# This is where the decision-making part happens.
async def take_turn():
    # Tell the server what to do in your turn.
    global sess

    # We will always tell our snake to move right.
    action = Action.MOVE(Direction.RIGHT())

    # Send our action to the server
    await sess.respond(action)  # May cause an ERR if the move is invalid.
                                # This ERR will appear as the next
                                # ClientNotification. A well-designed client
                                # should handle this situation.
    print('Moved right')

curio.run(main)
```

(this example is available under the terms of [CC0](https://creativecommons.org/publicdomain/zero/1.0)).

### Server session
TODO

## Low-level API: Messages
Messages play the central role in the protocol. These are units of information
carrying predetermined types of data that can be sent by a client or a server
at any time.

The `message.Message` class represents a message. `Message`s can be serialized
into and deserialized from byte strings via methods `.to_bytes()` and `.from_bytes()`.
This allows to store or transmit them as a sequence of bytes.

This class is an (emulated) [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type).
Python has no built-in capacity for ADTs, but the necessary functionality is provided
by the [`algebraic-data-types`](https://pypi.org/project/algebraic-data-types) package,
so, if you don't understand how `Message`s can be used or constructed,
you may want to consult its documentation.

This particular functionality may not be of a great interest for the users of this
library, so they might want to use the high-level API instead.

## Helper data types

### `data` module

- `Direction`: Algebraic data type denoting one of the four possible directions:
*up*, *down*, *left* and *right*.
- `Point`: A point with integer coordinates *x* and *y*.
- `SnakeState`: Stores the complete and accurate position of the snake
on the game field. It is given by the coordinates of the head (the segment
of the snake towards which the snake is moving) and the snake's tail,
given by the vector of `Direction`s. If you start from the head,
and then move along the direction `tail[0]`, then you will end up in the
first segment of the snake's tail. If then you follow the direction `tail[1]`,
you will get to the second segment of the tail and so on. That is, the
following snippet of code will output the positions of all segments of the snake:
```python
# Assume that snake_state is the SnakeState object of interest.
move_up = lambda x, y: (x, y + 1)
move_down = lambda x, y: (x, y - 1)
move_left = lambda x, y: (x - 1, y)
move_right = lambda x, y: (x + 1, y)

current_pos = snake_state.head
print(current_pos)

for direction in snake_state.tail:
    # Choose a direction
    function = direction.match(
        up = lambda: move_up,
        down = lambda: move_down,
        left = lambda: move_left,
        right = lambda: move_right,
    )

    # Obtain new coordinates
    x, y = function(current_pos.x, current_pos.y)
    current_pos = Point(x, y)

    # Print out the result
    print(current_pos)
```
- `FieldState`: Stores the information about the positions of the snakes and the objects in
the game field.
- `Object`: Algebraic data type representing an object in the game field. Currently,
the only variant is food.
- `Action`: Algebraic data type representing an action that can be performed by a
player in their turn. Currently, the only variant is to move to a specified
direction.

### `event` module

- `Event`: Algebraic data type representing an event that the server may report to the clients.
See the docstring for this class for details.
